#!./lua

local ui = require("ui")
local unistd = require("posix.unistd")
local poll = require("posix.poll")

ui.init()

local history = ui.in_root(ui.vbox({ name = "history", margin = 10, spacing = 4, fill = 0x000000 }, {}))

local pipes = {}
local add_prompt

local function text_eval(self, text)
   if #text > 0 then
      local fds = {}
      fds.stdout_r, fds.stdout_w = unistd.pipe()
      fds.stderr_r, fds.stderr_w = unistd.pipe()
      pipes[#history.children] = fds
      local childpid = unistd.fork()
      if childpid == 0 then
         -- child process
         unistd.close(fds.stdout_r)
         unistd.close(fds.stderr_r)
         unistd.dup2(fds.stdout_w, unistd.STDOUT_FILENO)
         unistd.dup2(fds.stderr_w, unistd.STDERR_FILENO)
         os.execute(text)
         os.exit(0)
      else
         add_prompt()
      end
   end
end

add_prompt = function()
   local text = ui.text("", {
      editable = true,
      eval = text_eval,
   })
   local window = ui.vbox({ name = "window", scrollable = false, min_w = 492, spacing = 4, fill = 0x333333, border = 0x00ffff }, {
      text
   })
   ui.set_focus(text)
   history:add_child(window)
end

add_prompt()

local fullscreen = false

ui.on_key(function(key, is_text, is_repeat)
   --print(key)
   if key == "Escape" then
      ui.quit()
   elseif key == "Ctrl L" then
      history.children = {}
      add_prompt()
   elseif key == "Ctrl F" and not is_repeat then
      fullscreen = not fullscreen
      ui.fullscreen(fullscreen)
   end
end)

ui.on_mouse_drag(function(x, y)
end)

local TEXT_W = 492 - 8

ui.run(function()
   for i, fds in pairs(pipes) do
      local data = poll.rpoll(fds.stdout_r, 0)
      if data == 1 then
         local win = history.children[i]
         local list
         if #win.children == 1 then
            local list = ui.vbox({ min_w = TEXT_W, max_h = 200, spacing = 4, scroll_by = 21, fill = 0x000000, border = 0x00ffff })
            win:add_child(list)
         else
            list = win.children[2]
         end
         if list then
            for line in unistd.read(fds.stdout_r, 1024):gmatch("[^\n]+") do
               list:add_child(ui.text(line, { max_w = TEXT_W }))
            end
         end
      end

      data = poll.rpoll(fds.stderr_r, 0)
      if data == 1 then
         local win = history.children[i]
         local list
         if #win.children == 1 then
            local list = ui.vbox({ min_w = TEXT_W, max_h = 200, spacing = 4, scroll_by = 21, fill = 0x000000, border = 0x00ffff })
            win:add_child(list)
         else
            list = win.children[2]
         end
         if list then
            -- FIXME correct handling of linebreaks
            for line in unistd.read(fds.stderr_r, 1024):gmatch("[^\n]+") do
               list:add_child(ui.text(line, { max_w = TEXT_W, color = 0xff7777 }))
            end
         end
      end
   end
end)
